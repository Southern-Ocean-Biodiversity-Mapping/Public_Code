---
title: "hmsc - cells - totalabundance - model diagnostics"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

Model diagnostics for hmsc

- DIVIDE EACH SPECIES' PREDICTIONS by the model coefficients for # of scorable points.
- look at the range of coefficients for scorable points
- BUT, what about the link function...?


example:
1000 points observed
sp.A coef: 0.9 -> only 90% increase with every extra image
sp.B coef: 1.3 -> 130% increase with every extra image


```{r, warning=FALSE, message=FALSE}
## fitting an hmsc using Otsos book, course scripts and : https://besjournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1111%2F2041-210X.13345&file=mee313345-sup-0002-AppendixS2.pdf
library(Hmsc)
library(bayesplot)
library(corrplot)
library(abind)
library(kableExtra) ## pretty tables
'%!in%' <- function(x,y)!('%in%'(x,y))

###############################
#res <- "500m"
res <- "2km"
###############################

pngs=FALSE
```

```{r}
model = 1
thin = 10  ## a value of 10 means every 10th iteration is kept (the higher the less correlated the samples are but the longer it takes)
samples = 800 ## how many total samples we want
transient = ceiling(0.5*samples*thin)
nChains = 4

#dir <- "C:/Users/jjansen/Desktop/science/Scripts/DP190101858/VM_scripts_and_data/"
dir <- "~/"
dir2 <- "/pvol3TB/2_fitting_and_running_models/"
dir3 <- "/pvol3TB/3_model_analysis/"


## model output
load(paste0(dir2,res,"_model_cells_",model,"_totalabundance_chains_4_thin_10_samples_",samples,".Rdata"))
## model fit
load(paste0(dir3,res,"_model_cells_",model,"_totalabundance_chains_4_thin_10_samples_",samples,"_MF.Rdata"))
## cross validation
load(paste0(dir3,res,"_model_cells_",model,"_totalabundance_chains_4_thin_10_samples_",samples,"_5foldcv.Rdata"))

## output for predicted vs observed (from script 2b)
load(paste0(dir3,res,"_model_cells_",model,"_totalabundance_chains_4_thin_10_samples_",samples,"_PredVsObs.Rdata"))

Y <- models[[2]]$Y

## reference model for standard diagnostics
m <- models[[2]]

## remove first bit of the species labels
colnames(m$Y) <- gsub('Biota - ', '', colnames(m$Y))
spNames <- "totalabundance"
```

## Model specifications {.tabset}

### Environment-spatial model

```{r, echo=FALSE}
message("Model summary")
models[[1]]
message("Model formula")
models[[1]]$XFormula
message("Model random levels")
models[[1]]$ranLevels
```

### Environment-only model

```{r, echo=FALSE}
message("Model summary")
models[[2]]
message("Model formula")
models[[2]]$XFormula
message("Model random levels")
models[[2]]$ranLevels
```

### Space-only model

```{r, echo=FALSE, eval=FALSE}
message("Model summary")
models[[3]]
message("Model formula")
models[[3]]$XFormula
message("Model random levels")
models[[3]]$ranLevels
```

### Environmental data

```{r, echo=FALSE}
summary(models[[2]]$X)
```

## Diagnostics {.tabset}

### MCMC convergence {.tabset}

```{r}
## extracting the posterior distribution from the model object
mpost <- list()
for(i in 1:2){
  mpost[[i]] <- convertToCodaObject(models[[i]])
}
```

#### graphical overview {.tabset}

```{r, results='asis', echo=FALSE, fig.height=5, fig.width=10}
for(i in 1){
  v <- (1:15)-15+15*i
  cat(spNames[i])
  cat("\n\n")
  mcmc.dat <- mpost[[2]]$Beta[,v]
  for(k in 1:4){colnames(mcmc.dat[[k]]) <- colnames(m$X)}
  plot(mcmc_trace(mcmc.dat))
  cat("\n\n")
}
### If good, the following is true:
### - different chain yielding the same results
### - chains rise and fall rapidly without apparent autocorrelation
### - the first half looks essentially identical to the second half
```

#### quantitative overview {.tabset}  
If good, the following is true:  
- effective sample size not too far away from sample size  
- potential scale reduction factors close to 1, indicating the multiple chains give consistent results  

##### effective size
```{r, echo=FALSE}
## we want high effective sample sizes (close to sample size)
es.dat <- effectiveSize(mpost[[2]]$Beta)
es.dat2 <- matrix(es.dat, ncol=15, byrow=TRUE)
colnames(es.dat2) <- colnames(m$X)
rownames(es.dat2) <- spNames
kable(es.dat2) ## ordered by names
```

##### potential scale reduction factor {.tabset}
```{r, echo=FALSE}
## the closer to 1 the better
gd.dat <- gelman.diag(mpost[[2]]$Beta)$psrf
gd.dat.pe <- matrix(gd.dat[,1], ncol=15, byrow=TRUE)
gd.dat.uci <- matrix(gd.dat[,2], ncol=15, byrow=TRUE)
colnames(gd.dat.pe) <- colnames(m$X)
rownames(gd.dat.pe) <- spNames
colnames(gd.dat.uci) <- colnames(m$X)
rownames(gd.dat.uci) <- spNames
```

###### Point estimate
```{r, echo=FALSE}
kable(gd.dat.pe)
```

###### Upper C.I.
```{r, echo=FALSE}
kable(gd.dat.uci)
```

### parameter estimates {.tabset}

#### parameter significance {.tabset}

These are the species' environmental responses. In red any positive relationships, in blue any negative ones.

```{r, echo=FALSE}
## 
postBeta = getPostEstimate(m, parName="Beta")
## original code, but hmsc version isn't flexible enough for the plotting:
# plotBeta(m, post=postBeta, param="Support", spNamesNumbers=c(TRUE,FALSE), mar=c(10,3,4,2), SpVector=match(1:hM$ns, as.numeric(as.factor(colnames(hM$Y)))))
## load custom version
source("~/Hmsc_plotBetaSimple.R")
```

##### Response direction
```{r, fig.height=5, fig.width=10, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_ParameterSignificance.png", width=1200, height=1200, res=300)}
plotBetaSimple(m, post=postBeta, param="Support", mar=c(10,3,4,2), main="Response direction")
if(pngs){dev.off()}
```

##### Mean response
```{r, fig.height=5, fig.width=10, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_ParameterResponse.png", width=1200, height=1200, res=300)}
plotBetaSimple(m, post=postBeta, param="Mean", mar=c(10,3,4,2), main="Mean response estimate")
if(pngs){dev.off()}
```


#### values

```{r}
s1 <- summary(mpost[[2]]$Beta)
s1
```

```{r, eval=FALSE}
#### parameter estimates - graph

# mean.df <- data.frame(matrix(ncol=12, nrow=83))
# sd.df <- data.frame(matrix(ncol=12, nrow=83))
# for(i in 1:12){
#   mean.df[,i] <- s1$statistics[seq(i,996,by=12),1]
#   sd.df[,i] <- s1$statistics[seq(i,996,by=12),3]
# }
# 
# par(mfrow=c(3,4))
# for(i in 2:15){
# plot(range(mean.df[,i]), xlim=c(0,1) ,xlab="Index" ,ylab="Intercept", main=colnames(models[[1]]$X)[i], col="white")
# for(j in 1:nrow(mean.df)){
#   if((sqrt(mean.df[j,i]^2)-sd.df[j,i])<=0){ # if coef plus/minus sd includes 0
#     cols <- "grey"
#   } else cols="black"
#   abline(0,mean.df[j,i], col=cols)
# }}
```

```{r, eval=FALSE}
#### species associations

# OmegaCor = computeAssociations(models[[2]])
# supportLevel = 0.95
# for (r in 1:models[[2]]$nr){
#   plotOrder = corrMatOrder(OmegaCor[[r]]$mean,order="AOE")
#   toPlot = ((OmegaCor[[r]]$support>supportLevel) +
#               (OmegaCor[[r]]$support<(1-supportLevel))>0)*OmegaCor[[r]]$mean
#   par(xpd=T)
#   colnames(toPlot)=rownames(toPlot)=gsub("_"," ",x=colnames(toPlot))
#   corrplot(toPlot[plotOrder,plotOrder], method = "color",
#            col=colorRampPalette(c("blue","white","red"))(200),
#            title="",type="lower",tl.col="black",tl.cex=.2, mar=c(0,0,6,0))
# }

```

#### environmental responses {.tabset}

```{r, echo=FALSE}
## load custom version
source("~/Hmsc_plotGradientSimple.R")
## can improve the function: 

## values for the unscaled environmental responses
load("~/Cell_level_env_2km_202412.Rdata")

## positions for the following depths
d.vals <- seq(0,-2000, by= -500)
d.vals.sc <- NA
d.vals.sc[1] <- (d.vals[1]-scale.means[24])/scale.sd[24]
d.vals.sc[2] <- (d.vals[2]-scale.means[24])/scale.sd[24]
d.vals.sc[3] <- (d.vals[3]-scale.means[24])/scale.sd[24]
d.vals.sc[4] <- (d.vals[4]-scale.means[24])/scale.sd[24]
d.vals.sc[5] <- (d.vals[5]-scale.means[24])/scale.sd[24]

## positions for the following slopes
s.vals <- c(0.1,0.3,1,3,10,20)
ls.vals <- log(s.vals)
ls.vals.sc <- NA
ls.vals.sc[1] <- (ls.vals[1]-scale.means[82])/scale.sd[82]
ls.vals.sc[2] <- (ls.vals[2]-scale.means[82])/scale.sd[82]
ls.vals.sc[3] <- (ls.vals[3]-scale.means[82])/scale.sd[82]
ls.vals.sc[4] <- (ls.vals[4]-scale.means[82])/scale.sd[82]
ls.vals.sc[5] <- (ls.vals[5]-scale.means[82])/scale.sd[82]
ls.vals.sc[6] <- (ls.vals[6]-scale.means[82])/scale.sd[82]
# Reverse the scaling
ls.vals.unscaled <- ls.vals.sc * scale.sd[82] + scale.means[82]
# Reverse the log transformation
s.vals.original <- exp(ls.vals.unscaled)

## positions for the following NPPs
npp.vals <- seq(0,900, by= 200)
npp.vals.sc <- NA
npp.vals.sc[1] <- (npp.vals[1]-scale.means[49])/scale.sd[49]
npp.vals.sc[2] <- (npp.vals[2]-scale.means[49])/scale.sd[49]
npp.vals.sc[3] <- (npp.vals[3]-scale.means[49])/scale.sd[49]
npp.vals.sc[4] <- (npp.vals[4]-scale.means[49])/scale.sd[49]
npp.vals.sc[5] <- (npp.vals[5]-scale.means[49])/scale.sd[49]

## positions for the following current speeds
curr.vals <- seq(0,0.3, by= 0.1)
curr.vals.sc <- NA
curr.vals.sc[1] <- (curr.vals[1]-scale.means[65])/scale.sd[65]
curr.vals.sc[2] <- (curr.vals[2]-scale.means[65])/scale.sd[65]
curr.vals.sc[3] <- (curr.vals[3]-scale.means[65])/scale.sd[65]
curr.vals.sc[4] <- (curr.vals[4]-scale.means[65])/scale.sd[65]

## positions for the following fluxes
f.vals <- c(10,100,1000,10000,100000)
lf.vals <- log(f.vals)
lf.vals.sc <- NA
lf.vals.sc[1] <- (lf.vals[1]-scale.means[74])/scale.sd[74]
lf.vals.sc[2] <- (lf.vals[2]-scale.means[74])/scale.sd[74]
lf.vals.sc[3] <- (lf.vals[3]-scale.means[74])/scale.sd[74]
lf.vals.sc[4] <- (lf.vals[4]-scale.means[74])/scale.sd[74]
lf.vals.sc[5] <- (lf.vals[5]-scale.means[74])/scale.sd[74]
# Reverse the scaling
lf.vals.unscaled <- lf.vals.sc * scale.sd[74] + scale.means[74]
# Reverse the log transformation
options(scipen=999)
f.vals.original <- exp(lf.vals.unscaled)
```

```{r, echo=FALSE}
# The plotGradient function produces plots of predicted values along the gradient.
# • measure = “S” plots species richness
# • measure = “Y” plots the response of a species given by index
# • measure = “T” plots community-weighed mean values of traits given by index

## depth
Gradient.d = constructGradient(models[[2]], focalVariable="depth")
predY.d = predict(models[[2]], XData=Gradient.d$XDataNew, studyDesign=Gradient.d$studyDesignNew, ranLevels=Gradient.d$rLNew, expected=TRUE)

## slope
Gradient.s = constructGradient(models[[2]], focalVariable="logslope")
predY.s = predict(models[[2]], XData=Gradient.s$XDataNew, studyDesign=Gradient.s$studyDesignNew, ranLevels=Gradient.s$rLNew, expected=TRUE)

## npp
Gradient.n = constructGradient(models[[2]], focalVariable="npp_mean")
predY.n = predict(models[[2]], XData=Gradient.n$XDataNew, studyDesign=Gradient.n$studyDesignNew, ranLevels=Gradient.n$rLNew, expected=TRUE)

## current speed
Gradient.c = constructGradient(models[[2]], focalVariable="seafloorcurrents_mean")
predY.c = predict(models[[2]], XData=Gradient.c$XDataNew, studyDesign=Gradient.c$studyDesignNew, ranLevels=Gradient.c$rLNew, expected=TRUE)

## flux
Gradient.f = constructGradient(models[[2]], focalVariable="log.flux.mean")
predY.f = predict(models[[2]], XData=Gradient.f$XDataNew, studyDesign=Gradient.f$studyDesignNew, ranLevels=Gradient.f$rLNew, expected=TRUE)
```

##### Depth

```{r, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_RichnessDepth.png", width=2400, height=1200, res=300)}
plotGradientSimple(models[[2]], Gradient.d, pred=predY.d, measure="S", las=1, showData = TRUE, x_ticks = d.vals.sc, x_labels = d.vals, showPosteriorSupport = FALSE)#, main='Species richness (measure="S")'
if(pngs){dev.off()}
```

##### Slope

```{r, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_RichnessSlope.png", width=2400, height=1200, res=300)}
plotGradientSimple(models[[2]], Gradient.s, pred=predY.s, measure="S", las=1, showData=TRUE, x_ticks=ls.vals.sc, x_labels=s.vals.original, xlabel="slope", showPosteriorSupport = FALSE)
if(pngs){dev.off()}
```

##### NPP

```{r, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_RichnessNPP.png", width=2400, height=1200, res=300)}
plotGradientSimple(models[[2]], Gradient.n, pred=predY.n, measure="S", las=1, showData=TRUE, x_ticks=npp.vals.sc, x_labels=npp.vals, xlabel="npp mean", showPosteriorSupport = FALSE)
if(pngs){dev.off()}
```

##### Current speed

```{r, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_RichnessCurrent.png", width=2400, height=1200, res=300)}
plotGradientSimple(models[[2]], Gradient.c, pred=predY.c, measure="S", las=1, showData = TRUE, x_ticks=curr.vals.sc, x_labels=curr.vals, xlabel="seafloor current speed mean", showPosteriorSupport = FALSE)
if(pngs){dev.off()}
```

##### Flux

```{r, echo=FALSE}
if(pngs){png("HMSC_totabund_EnvOnly_RichnessFlux.png", width=2400, height=1200, res=300)}
plotGradientSimple(models[[2]], Gradient.f, pred=predY.f, measure="S", las=1, showData = TRUE, x_ticks=lf.vals.sc, x_labels=f.vals.original, xlabel="particle flux", showPosteriorSupport = FALSE) #, main='Species richness (measure="S")'
if(pngs){dev.off()}
```


### assess explanatory power {.tabset}

#### Model Fit

From the Hmsc vignette:  
All measures of model fit are based on comparing the posterior predictive distribution (predY)) to the observed values (hM$Y). The predicted distribution is first summarized to a single matrix of predicted values by taking the posterior mean (for normal and probit models) or posterior median (for Poisson models). All measures of model fit are given as vectors with one value for each species.  

The kinds of measures of model fit depend on the type of response variable.  
- For all types of response variables, root-mean-square error (RMSE) between predicted and observed values is computed.  
- For normal models, R2 is computed as squared pearson correlation between observed and predicted values, times the sign of the correlation.  
- For probit models, Tjur R2 and AUC are computed.  
- For Poisson models, a pseudo-R2 is computed as squared spearman correlation between observed and predicted values, times the sign of the correlation (SR2).  
- For Poisson models, the observed and predicted data are also truncated to occurrences (presence-absences), for which the same measures are given as for the probit models (O.RMSE, O.AUC and O.TjurR2).  
- For Poisson models, the observed and predicted data are also subsetted to conditional on presence, for which the root-mean-square error and pseudo-R2 based on squared spearman correlation are computed (C.RMSE, C.SR2).  

The measures O.RMSE, O.AUC, O.TjurR2, C.RMSE and C.SR2 can be computed only if the option expected=FALSE has been used when making the predictions. If the model includes a mixture of response variable types, the resulting measures of model fit contain NA’s for those response variables for which they cannot be computed.

##### RMSE

```{r, echo=FALSE}
MF[[2]]$RMSE
MF.cv[[2]]$RMSE
```

##### SR2

```{r, echo=FALSE}
MF[[2]]$SR2
MF.cv[[2]]$SR2
```

#### Predicted Abundance vs Observed

```{r}
preds.cv.median = as.data.frame(apply(preds.cv[[1]], 1:2, median))
preds.cv.eo.median = as.data.frame(apply(preds.cv[[2]], 1:2, median))

```


##### **Total abundance at each site (454 data-points)**

```{r, fig.height=8, fig.width=8}
pred.ab <- as.vector(predY.median)[[1]]
pred.ab.cv <- as.vector(preds.cv.eo.median)[[1]]
obs.ab <- as.vector(Y)#/5430*540
par(mfrow=c(2,2))

plot(pred.ab, obs.ab, pch=16, cex=0.2, main="Environment-only model",
       xlab="predicted", ylab="observed", xlim=c(0,1600), ylim=c(0,1600))
abline(0,1, lty=2, col="grey")

plot(pred.ab.cv, obs.ab, pch=16, cex=0.2, main="Environment-only model - CV",
       xlab="predicted", ylab="observed", xlim=c(0,1600), ylim=c(0,1600))
abline(0,1, lty=2, col="grey")

plot(pred.ab, obs.ab, pch=16, cex=0.2, main="Environment-only model - zoom",
      xlab="predicted", ylab="observed", xlim=c(0,700), ylim=c(0,700))
abline(0,1, lty=2, col="grey")

plot(pred.ab.cv, obs.ab, pch=16, cex=0.2, main="Environment-only model - CV - zoom",
      xlab="predicted", ylab="observed", xlim=c(0,700), ylim=c(0,700))
abline(0,1, lty=2, col="grey")

```

#### Variance explained - Environment-spatial model

The pseudo-R2 (SR2) is computed as squared spearman correlation between observed and predicted values, times the sign of the correlation.

```{r, warning=FALSE}
## what proportion of variance is explained by the different models and their parameters
groupnames = c("bathymetry", "waterproperties","food","effort")
group = c(1,1,1,1,1,1,2,2,2,2,3,3,3,4)
VP <- list()
for(i in 1:2){
  VP[[i]] = computeVariancePartitioning(models[[i]],group=group, groupnames=groupnames)
}
```

```{r, warning=FALSE, fig.height=2, fig.width=10}
## preparing the data like in the plotVariancePartitioning function
## but re-arrange data alphabetically
dat <- VP[[1]]
hM <- models[[1]]
ng = dim(dat$vals)[1]
colnames(dat$vals) <- spNames
##
leg = dat$groupnames
for (r in 1:hM$nr) {
    leg = c(leg, paste("Random: ", hM$rLNames[r], sep = ""))
}
means = round(100 * rowMeans(dat$vals), 1)
for (i in 1:ng) {
    leg[i] = paste(leg[i], " (mean = ", toString(means[i]), 
        ")", sep = "")
}
if(pngs){png("HMSC_totabund_EnvSpatial_VarianceExplained.png", width=3600, height=1200, res=300)}
par(mfrow=c(1,4), mar=c(10,2,1,1), oma=c(0,15,0,0))
plot.new()
barplot(dat$vals, horiz=TRUE, col=heat.colors(ng), las=1, legend=leg, main="variance partitioning", args.legend=list(x=1.1, y=-0.4, bty = "n"))
barplot(MF[[1]]$SR2, horiz=TRUE, las=1, xlim=c(0,1), main="SR2 full model vs CV", args.legend=list(x=1.1, y=-0.4, bty = "n", fill=c("black","grey50")))
barplot(MF.cv[[1]]$SR2, horiz=TRUE, add=TRUE, col="grey50")
abline(v=0.2, lty=2)
abline(v=0.4, lty=2)
abline(v=0.6, lty=2)
abline(v=0.8, lty=2)
abline(v=1, lty=2)
barplot(MF.cv[[1]]$RMSE, horiz=TRUE, col="grey50", las=1, xlim=c(0,200), main="RMSE full model vs CV", args.legend=list(x=1, y=0, bty = "n", fill=c("black","grey50")))
barplot(MF[[1]]$RMSE, horiz=TRUE, add=TRUE)
abline(v=0.2, lty=2)
abline(v=0.4, lty=2)
abline(v=0.6, lty=2)
abline(v=0.8, lty=2)
abline(v=1, lty=2)
if(pngs){dev.off()}
```

#### Variance explained - environment-only model
```{r, warning=FALSE, fig.height=2, fig.width=10}
dat <- VP[[2]]
hM <- models[[2]]
ng = dim(dat$vals)[1]
colnames(dat$vals) <- spNames
##
leg = names(means)
means = round(100 * rowMeans(dat$vals), 1)
for (i in 1:ng) {
    leg[i] = paste(leg[i], " (mean = ", toString(means[i]), 
        ")", sep = "")
}

if(pngs){png("HMSC_totabund_EnvOnly_VarianceExplained.png", width=3600, height=1200, res=300)}
par(mfrow=c(1,4), mar=c(10,2,1,1), oma=c(0,15,0,0))
plot.new()
barplot(dat$vals, horiz=TRUE, col=heat.colors(ng+1), las=1, legend=leg, main="variance partitioning", args.legend=list(x=1.1, y=-0.4, bty = "n"))
barplot(MF[[2]]$SR2, horiz=TRUE, las=1, xlim=c(0,1), main="SR2 full model vs CV", args.legend=list(x=1.1, y=-0.4, bty = "n", fill=c("black","grey50")))
barplot(MF.cv[[2]]$SR2, horiz=TRUE, add=TRUE, col="grey50")
abline(v=0.2, lty=2)
abline(v=0.4, lty=2)
abline(v=0.6, lty=2)
abline(v=0.8, lty=2)
abline(v=1, lty=2)
barplot(MF.cv[[2]]$RMSE, horiz=TRUE, col="grey50", las=1, xlim=c(0,200), main="RMSE full model vs CV", args.legend=list(x=1, y=0, bty = "n", fill=c("black","grey50")))
barplot(MF[[2]]$RMSE, horiz=TRUE, add=TRUE)
abline(v=0.2, lty=2)
abline(v=0.4, lty=2)
abline(v=0.6, lty=2)
abline(v=0.8, lty=2)
abline(v=1, lty=2)
if(pngs){dev.off()}
```

#### Scale of the random effect

```{r}
## estimated scale of the spatial random effect (SOMETHING WEIRD HERE)
round(summary(mpost[[2]]$Alpha[[1]], quantiles=c(0.025,0.5,0.975))[[2]],2)
```

### cross-validation

```{r, echo=FALSE, eval=FALSE}
#### cross-validation
## RMSE for full vs environment-only model, for both full and cv-models
sel <- order(MF[[1]]$RMSE)
plot(MF[[1]]$RMSE[sel], pch=16, main="RMSE")
points(MF.cv[[1]]$RMSE[sel], pch=16, col="red")
legend("topleft", pch=16, col=c("black","red"), legend=c(paste0("full fm (mean RMSE = ",round(mean(MF[[1]]$RMSE),2),")"), paste0("CV fm (mean RMSE = ",round(mean(MF.cv[[2]]$RMSE),2),")")))
```

The pseudo-R2 (SR2) is computed as squared spearman correlation between observed and predicted values, times the sign of the correlation.

```{r, echo=FALSE, eval=FALSE}
## SR2 for full vs environment-only model, for both full and cv-models
sel <- order(MF[[1]]$SR2)
plot(MF[[1]]$SR2[sel], pch=16, main="SR2")
points(MF.cv[[1]]$SR2[sel], pch=16, col="red")
legend("topleft", pch=16, col=c("black","red"), legend=c(paste0("full fm (mean SR2 = ",round(mean(MF[[1]]$SR2),2),")"), paste0("CV fm (mean SR2 = ",round(mean(MF.cv[[2]]$SR2),2),")")))
```

```{r, fig.height=8, fig.width=8, echo=FALSE, eval=FALSE}
#### cross-validation
par(mfrow=c(2,2)) 

## RMSE for full vs environment-only model, for both full and cv-models
sel <- order(MF[[1]]$RMSE)
plot(MF[[1]]$RMSE[sel], pch=16, main="RMSE")
points(MF[[2]]$RMSE[sel], pch=16, col="grey50")
points(MF.cv[[1]]$RMSE[sel], pch=16, col="red")
points(MF.cv[[2]]$RMSE[sel], pch=16, col="orchid")
legend("topleft", legend=c("full fm","full env-only", "CV fm","CV env-only"),col=c("black","grey50","red","orchid"), pch=16)

## SR2 for full vs environment-only model, for both full and cv-models
sel <- order(MF[[1]]$SR2)
plot(MF[[1]]$SR2[sel], pch=16, main="SR2")
points(MF[[2]]$SR2[sel], pch=16, col="grey50")
points(MF.cv[[1]]$SR2[sel], pch=16, col="red")
points(MF.cv[[2]]$SR2[sel], pch=16, col="orchid")
legend("topleft", legend=c("full fm","full env-only", "CV fm","CV env-only"),col=c("black","grey50","red","orchid"), pch=16)
```



```{r, fig.height=15, fig.width=10, echo=FALSE, eval=FALSE}
#### difference in RMSE between full models (light grey) and CV models (dark grey)

## preparing the data like in the plotVariancePartitioning function
## but re-arrange data alphabetically
sel <- order(colnames(VP[[1]]$vals))
dat <- VP[[1]]
hM <- models[[1]]
ng = dim(dat$vals)[1]
##
leg = dat$groupnames
for (r in 1:hM$nr) {
    leg = c(leg, paste("Random: ", hM$rLNames[r], sep = ""))
}
means = round(100 * rowMeans(dat$vals), 1)
for (i in 1:ng) {
    leg[i] = paste(leg[i], " (mean = ", toString(means[i]), 
        ")", sep = "")
}

par(mfrow=c(1,4), mar=c(4,2,1,1))
plot.new()
barplot(dat$vals[,rev(sel)], horiz=TRUE, col=heat.colors(ng), las=1, legend=leg, main="variance partitioning")
barplot(MF[[1]]$SR2[rev(sel)], horiz=TRUE, las=1, xlim=c(0,1), main="SR2 full model vs CV")
barplot(MF.cv[[1]]$SR2[rev(sel)], horiz=TRUE, add=TRUE, col="grey50")
abline(v=0.2, lty=2)
abline(v=0.4, lty=2)
abline(v=0.6, lty=2)
abline(v=0.8, lty=2)
abline(v=1, lty=2)
barplot(MF[[1]]$RMSE[rev(sel)], horiz=TRUE, las=1, main="RMSE")
barplot(MF.cv[[1]]$RMSE[rev(sel)], horiz=TRUE, add=TRUE, col="grey50")
```

```{r, fig.height=5, fig.width=5, eval=FALSE}
dat <- VP[[1]]
par(mfrow=c(2,2))
diff.RMSE <- MF[[1]]$RMSE[rev(sel)]-MF.cv[[1]]$RMSE[rev(sel)]
diff.SR2 <- MF[[1]]$SR2[rev(sel)]-MF.cv[[1]]$SR2[rev(sel)]
plot(diff.RMSE, MF[[1]]$SR2[rev(sel)], ylab="SR2")
plot(diff.RMSE, dat$vals[5,], ylab="cellID importance")
plot(diff.RMSE, dat$vals[6,], ylab="surveyID importance")
plot(diff.RMSE, dat$vals[4,], ylab="effort importance")
```

